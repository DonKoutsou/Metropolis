[gd_scene load_steps=22 format=2]

[ext_resource path="res://Assets/Skele_Arm/Arm_Skel_ArmSkele_Normal.png" type="Texture" id=1]
[ext_resource path="res://Scripts/Furniture.cs" type="Script" id=2]
[ext_resource path="res://Scenes/HUD/ActionComponent.tscn" type="PackedScene" id=3]
[ext_resource path="res://Assets/FastLegs/Textures/Body_Texture_M_Legs_BaseColor.png" type="Texture" id=4]
[ext_resource path="res://Assets/FastLegs/Textures/Body_Texture_M_Legs_OcclusionRoughnessMetallic.png" type="Texture" id=5]
[ext_resource path="res://Scenes/Items/MapItem.tscn" type="PackedScene" id=6]
[ext_resource path="res://Assets/FastLegs/Textures/Body_Texture_M_Legs_Normal.png" type="Texture" id=7]
[ext_resource path="res://Scenes/Characters/Posed/DeadMachine.tscn" type="PackedScene" id=8]
[ext_resource path="res://Assets/Skele_Arm/Arm_Skel_ArmSkele_BaseColor.png" type="Texture" id=10]
[ext_resource path="res://Assets/Skele_Arm/Arm_Skel_ArmSkele_OcclusionRoughnessMetallic.png" type="Texture" id=11]
[ext_resource path="res://Assets/TerainTex/Ground059_1K-JPG/Ground059_1K-JPG_AmbientOcclusion.jpg" type="Texture" id=12]
[ext_resource path="res://Assets/TerainTex/Ground059_1K-JPG/Ground059_1K-JPG_Color.jpg" type="Texture" id=13]
[ext_resource path="res://Assets/TerainTex/Ground059_1K-JPG/Ground059_1K-JPG_NormalGL.jpg" type="Texture" id=14]
[ext_resource path="res://Assets/TerainTex/Ground059_1K-JPG/Ground059_1K-JPG_Roughness.jpg" type="Texture" id=15]

[sub_resource type="Animation" id=5]
resource_name = "Open"
length = 1.5

[sub_resource type="Animation" id=6]
length = 0.001

[sub_resource type="CapsuleShape" id=7]
radius = 1.14138
height = 6.0888

[sub_resource type="Shader" id=1]
code = "// 2022 Kasper Arnklit Frandsen - Public Domain - No Rights Reserved

// WORLD NORMAL MIX SHADER
// This shader can  be used to mix two PBR materials based on a world normal. This is useful for
// effects such as snow on top of an object, or grass growing on top of an object.

// COMMENTS:
// LINE 43 - We unpack the background normal map.
// LINE 44 - Recalculate z-component of the normal map with the Pythagorean theorem.
// LINE 45 - Apply the tangent-space normal map to the view-space normals.
// LINE 46 - Convert the world up vector into view-space with a matrix multiplication.
// LINE 47 - Compare the up vector to the surface with the normal map applied using the dot product.
// LINE 48 - Remap the dot-product to a clamped mask using the smoothstep function.
// LINE 50 - Mix the various textures and apply them, using the mask.

shader_type spatial;
render_mode world_vertex_coords;
uniform float offset : hint_range(-1.0, 1.0) = 0.5;
uniform float fade : hint_range(0.0, 1.0) = 0.1;
uniform float NormalForce;

uniform sampler2D albedo_texture_fg : hint_albedo;
uniform sampler2D Rough_texture_fg : hint_white;
uniform sampler2D AO_texture_fg : hint_white;
uniform vec4 roughness_texture_channel;
uniform sampler2D normal_texture_fg : hint_normal;

uniform sampler2D albedo_texture_bg : hint_albedo;
uniform sampler2D ORM_BG : hint_albedo;
uniform sampler2D normal_texture_bg : hint_normal;

varying vec3 uv1_triplanar_pos;
uniform float uv1_blend_sharpness;
varying vec3 uv1_power_normal;
uniform vec3 uv1_scale;

uniform vec3 uv1_offset;


void vertex() {
	TANGENT = vec3(0.0,0.0,-1.0) * abs(NORMAL.x);
	TANGENT+= vec3(1.0,0.0,0.0) * abs(NORMAL.y);
	TANGENT+= vec3(1.0,0.0,0.0) * abs(NORMAL.z);
	TANGENT = normalize(TANGENT);
	BINORMAL = vec3(0.0,1.0,0.0) * abs(NORMAL.x);
	BINORMAL+= vec3(0.0,0.0,-1.0) * abs(NORMAL.y);
	BINORMAL+= vec3(0.0,1.0,0.0) * abs(NORMAL.z);
	BINORMAL = normalize(BINORMAL);
	uv1_power_normal=pow(abs(NORMAL),vec3(uv1_blend_sharpness));
	uv1_power_normal/=dot(uv1_power_normal,vec3(1.0));
	uv1_triplanar_pos = VERTEX * uv1_scale + uv1_offset;
	uv1_triplanar_pos *= vec3(1.0,-1.0, 1.0);
}


vec4 triplanar_texture(sampler2D p_sampler,vec3 p_weights,vec3 p_triplanar_pos) {
	vec4 samp=vec4(0.0);
	samp+= texture(p_sampler,p_triplanar_pos.xy) * p_weights.z;
	samp+= texture(p_sampler,p_triplanar_pos.xz) * p_weights.y;
	samp+= texture(p_sampler,p_triplanar_pos.zy * vec2(-1.0,1.0)) * p_weights.x;
	return samp;
}

	


void fragment() {
	vec3 albedo_tex_fg = triplanar_texture(albedo_texture_fg,uv1_power_normal,uv1_triplanar_pos).xyz;
	vec3 normal_tex_fg = triplanar_texture(normal_texture_fg,uv1_power_normal,uv1_triplanar_pos).xyz;
	
	//vec3 albedo_tex_bg = triplanar_texture(albedo_texture_bg,uv1_power_normal,uv2_triplanar_pos).xyz;
	//vec3 normal_tex_bg = triplanar_texture(normal_texture_bg,uv1_power_normal,uv2_triplanar_pos).xyz;
	
	vec3 albedo_tex_bg = texture(albedo_texture_bg, UV).xyz;
	vec3 normal_tex_bg = texture(normal_texture_bg, UV).xyz;
	
	//float rough = texture(Rough_texture_fg, bg_uv);
	float roughness_texfg = dot(triplanar_texture(Rough_texture_fg,uv1_power_normal,uv1_triplanar_pos),roughness_texture_channel);
	//float roughness_texbg = dot(triplanar_texture(Rough_texture_bg,uv1_power_normal,uv2_triplanar_pos),roughness_texture_channel);
	float roughness_texbg = texture(ORM_BG, UV).g;
	
	float metaltex_bh = texture(ORM_BG, UV).b;
	
	float ao_texfg = dot(triplanar_texture(AO_texture_fg,uv1_power_normal,uv1_triplanar_pos),roughness_texture_channel);
	//float ao_texbg = dot(triplanar_texture(AO_texture_bg,uv1_power_normal,uv2_triplanar_pos),roughness_texture_channel);
	float ao_texbg = texture(ORM_BG, UV).r;
	
	
	vec3 bg_normal = normal_tex_bg * 2.0 - 1.0;
	bg_normal.z = sqrt(1.0 - bg_normal.x * bg_normal.x - bg_normal.y * bg_normal.y);
	vec3 normal_applied = bg_normal.x * TANGENT + bg_normal.y * BINORMAL + bg_normal.z * NORMAL;
	vec3 up_vector_viewspace = mat3(INV_CAMERA_MATRIX) * vec3(0.0, 1.0, 0.0);
	float dot_product = dot(up_vector_viewspace, normal_applied);
	float mask = smoothstep(offset - fade, offset + fade, dot_product);
	
	//vec3 albedo_tex = triplanar_texture(texture_albedo,uv1_power_normal,uv1_triplanar_pos);
	
	ALBEDO = mix(albedo_tex_bg, albedo_tex_fg, mask);
	AO = mix(ao_texfg, ao_texbg, mask);
	AO_LIGHT_AFFECT = 2.0;
	ROUGHNESS = mix(roughness_texfg, roughness_texbg, mask);
	METALLIC = mix(metaltex_bh, 0.0, mask);
	NORMALMAP = mix(normal_tex_bg, normal_tex_fg, mask);
	NORMALMAP_DEPTH = NormalForce;
}"

[sub_resource type="ShaderMaterial" id=2]
shader = SubResource( 1 )
shader_param/offset = 0.516
shader_param/fade = 0.243
shader_param/NormalForce = 2.0
shader_param/roughness_texture_channel = Plane( 0, 0, 0, 1 )
shader_param/uv1_blend_sharpness = 1.532
shader_param/uv1_scale = Vector3( 0.5, 0.5, 0.5 )
shader_param/uv1_offset = Vector3( 0, 0, 0 )
shader_param/albedo_texture_fg = ExtResource( 13 )
shader_param/Rough_texture_fg = ExtResource( 15 )
shader_param/AO_texture_fg = ExtResource( 12 )
shader_param/normal_texture_fg = ExtResource( 14 )
shader_param/albedo_texture_bg = ExtResource( 10 )
shader_param/ORM_BG = ExtResource( 11 )
shader_param/normal_texture_bg = ExtResource( 1 )

[sub_resource type="Shader" id=8]
code = "// 2022 Kasper Arnklit Frandsen - Public Domain - No Rights Reserved

// WORLD NORMAL MIX SHADER
// This shader can  be used to mix two PBR materials based on a world normal. This is useful for
// effects such as snow on top of an object, or grass growing on top of an object.

// COMMENTS:
// LINE 43 - We unpack the background normal map.
// LINE 44 - Recalculate z-component of the normal map with the Pythagorean theorem.
// LINE 45 - Apply the tangent-space normal map to the view-space normals.
// LINE 46 - Convert the world up vector into view-space with a matrix multiplication.
// LINE 47 - Compare the up vector to the surface with the normal map applied using the dot product.
// LINE 48 - Remap the dot-product to a clamped mask using the smoothstep function.
// LINE 50 - Mix the various textures and apply them, using the mask.

shader_type spatial;
render_mode world_vertex_coords;
uniform float offset : hint_range(-1.0, 1.0) = 0.5;
uniform float fade : hint_range(0.0, 1.0) = 0.1;
uniform float NormalForce;

uniform sampler2D albedo_texture_fg : hint_albedo;
uniform sampler2D Rough_texture_fg : hint_white;
uniform sampler2D AO_texture_fg : hint_white;
uniform vec4 roughness_texture_channel;
uniform sampler2D normal_texture_fg : hint_normal;

uniform sampler2D albedo_texture_bg : hint_albedo;
uniform sampler2D ORM_BG : hint_albedo;
uniform sampler2D normal_texture_bg : hint_normal;

varying vec3 uv1_triplanar_pos;
uniform float uv1_blend_sharpness;
varying vec3 uv1_power_normal;
uniform vec3 uv1_scale;

uniform vec3 uv1_offset;


void vertex() {
	TANGENT = vec3(0.0,0.0,-1.0) * abs(NORMAL.x);
	TANGENT+= vec3(1.0,0.0,0.0) * abs(NORMAL.y);
	TANGENT+= vec3(1.0,0.0,0.0) * abs(NORMAL.z);
	TANGENT = normalize(TANGENT);
	BINORMAL = vec3(0.0,1.0,0.0) * abs(NORMAL.x);
	BINORMAL+= vec3(0.0,0.0,-1.0) * abs(NORMAL.y);
	BINORMAL+= vec3(0.0,1.0,0.0) * abs(NORMAL.z);
	BINORMAL = normalize(BINORMAL);
	uv1_power_normal=pow(abs(NORMAL),vec3(uv1_blend_sharpness));
	uv1_power_normal/=dot(uv1_power_normal,vec3(1.0));
	uv1_triplanar_pos = VERTEX * uv1_scale + uv1_offset;
	uv1_triplanar_pos *= vec3(1.0,-1.0, 1.0);
}


vec4 triplanar_texture(sampler2D p_sampler,vec3 p_weights,vec3 p_triplanar_pos) {
	vec4 samp=vec4(0.0);
	samp+= texture(p_sampler,p_triplanar_pos.xy) * p_weights.z;
	samp+= texture(p_sampler,p_triplanar_pos.xz) * p_weights.y;
	samp+= texture(p_sampler,p_triplanar_pos.zy * vec2(-1.0,1.0)) * p_weights.x;
	return samp;
}

	


void fragment() {
	vec3 albedo_tex_fg = triplanar_texture(albedo_texture_fg,uv1_power_normal,uv1_triplanar_pos).xyz;
	vec3 normal_tex_fg = triplanar_texture(normal_texture_fg,uv1_power_normal,uv1_triplanar_pos).xyz;
	
	//vec3 albedo_tex_bg = triplanar_texture(albedo_texture_bg,uv1_power_normal,uv2_triplanar_pos).xyz;
	//vec3 normal_tex_bg = triplanar_texture(normal_texture_bg,uv1_power_normal,uv2_triplanar_pos).xyz;
	
	vec3 albedo_tex_bg = texture(albedo_texture_bg, UV).xyz;
	vec3 normal_tex_bg = texture(normal_texture_bg, UV).xyz;
	
	//float rough = texture(Rough_texture_fg, bg_uv);
	float roughness_texfg = dot(triplanar_texture(Rough_texture_fg,uv1_power_normal,uv1_triplanar_pos),roughness_texture_channel);
	//float roughness_texbg = dot(triplanar_texture(Rough_texture_bg,uv1_power_normal,uv2_triplanar_pos),roughness_texture_channel);
	float roughness_texbg = texture(ORM_BG, UV).g;
	
	float metaltex_bh = texture(ORM_BG, UV).b;
	
	float ao_texfg = dot(triplanar_texture(AO_texture_fg,uv1_power_normal,uv1_triplanar_pos),roughness_texture_channel);
	//float ao_texbg = dot(triplanar_texture(AO_texture_bg,uv1_power_normal,uv2_triplanar_pos),roughness_texture_channel);
	float ao_texbg = texture(ORM_BG, UV).r;
	
	
	vec3 bg_normal = normal_tex_bg * 2.0 - 1.0;
	bg_normal.z = sqrt(1.0 - bg_normal.x * bg_normal.x - bg_normal.y * bg_normal.y);
	vec3 normal_applied = bg_normal.x * TANGENT + bg_normal.y * BINORMAL + bg_normal.z * NORMAL;
	vec3 up_vector_viewspace = mat3(INV_CAMERA_MATRIX) * vec3(0.0, 1.0, 0.0);
	float dot_product = dot(up_vector_viewspace, normal_applied);
	float mask = smoothstep(offset - fade, offset + fade, dot_product);
	
	//vec3 albedo_tex = triplanar_texture(texture_albedo,uv1_power_normal,uv1_triplanar_pos);
	
	ALBEDO = mix(albedo_tex_bg, albedo_tex_fg, mask);
	AO = mix(ao_texfg, ao_texbg, mask);
	AO_LIGHT_AFFECT = 2.0;
	ROUGHNESS = mix(roughness_texfg, roughness_texbg, mask);
	METALLIC = mix(metaltex_bh, 0.0, mask);
	NORMALMAP = mix(normal_tex_bg, normal_tex_fg, mask);
	NORMALMAP_DEPTH = NormalForce;
}"

[sub_resource type="ShaderMaterial" id=4]
shader = SubResource( 8 )
shader_param/offset = 0.516
shader_param/fade = 0.243
shader_param/NormalForce = 2.0
shader_param/roughness_texture_channel = Plane( 0, 0, 0, 1 )
shader_param/uv1_blend_sharpness = 1.532
shader_param/uv1_scale = Vector3( 0.5, 0.5, 0.5 )
shader_param/uv1_offset = Vector3( 0, 0, 0 )
shader_param/albedo_texture_fg = ExtResource( 13 )
shader_param/Rough_texture_fg = ExtResource( 15 )
shader_param/AO_texture_fg = ExtResource( 12 )
shader_param/normal_texture_fg = ExtResource( 14 )
shader_param/albedo_texture_bg = ExtResource( 4 )
shader_param/ORM_BG = ExtResource( 5 )
shader_param/normal_texture_bg = ExtResource( 7 )

[node name="Furniture" type="StaticBody" groups=["Interactables"]]
collision_layer = 16
collision_mask = 0
script = ExtResource( 2 )
FurnitureDescription = "Μια ντουλάπα..."
ToHighLight = [ NodePath("DeadMachine/Body001") ]
ItemToSpawnWith = ExtResource( 6 )

[node name="ActionComponent" parent="." instance=ExtResource( 3 )]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 4.44241, 0.502798 )
ActionDistance = 10.0

[node name="AnimationPlayer" type="AnimationPlayer" parent="."]
anims/Open = SubResource( 5 )
anims/RESET = SubResource( 6 )

[node name="CollisionShape2" type="CollisionShape" parent="."]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0.289204, -0.318735 )
shape = SubResource( 7 )

[node name="DeadMachine" parent="." instance=ExtResource( 8 )]

[node name="Arm_L001" parent="DeadMachine" index="0"]
visible = false

[node name="Arm_R001" parent="DeadMachine" index="1"]
visible = true
material/0 = SubResource( 2 )

[node name="Leg_R001" parent="DeadMachine" index="6"]
material/0 = SubResource( 4 )

[editable path="DeadMachine"]
