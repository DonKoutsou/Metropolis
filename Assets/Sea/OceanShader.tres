[gd_resource type="ShaderMaterial" load_steps=10 format=2]

[ext_resource path="res://Assets/Water/textures/water/gerstner_normal.png" type="Texture" id=2]
[ext_resource path="res://Assets/Water/textures/post/lense_glare_a.png" type="Texture" id=3]
[ext_resource path="res://Assets/Water/textures/water/gerstner_height.png" type="Texture" id=5]
[ext_resource path="res://Assets/Water/textures/water/foam_normal.png" type="Texture" id=10]
[ext_resource path="res://Assets/Water/textures/water/gradients/water_gradient_b.tres" type="Gradient" id=12]

[sub_resource type="Shader" id=10]
code = "shader_type spatial;

render_mode async_visible,blend_mix,depth_draw_always,cull_disabled,diffuse_lambert,specular_schlick_ggx;

uniform bool IsRaining = false;

uniform float ring_width : hint_range(0.0, 500.0) = 50.0f;
//uniform float fadeout : hint_range(0.0, 1.0) = 0.2;
//uniform sampler2D pattern;
//uniform vec4 ring_color : hint_color;

uniform sampler2D water_color : hint_albedo;

uniform sampler2D foam_normal_map : hint_normal;
uniform sampler2D foam_albedo_map : hint_albedo;

uniform sampler2D gerstner_height_map : hint_albedo;
uniform sampler2D gerstner_normal_map : hint_normal;
//uniform sampler2D detail_normal_map : hint_normal;
uniform sampler2D water_highlight_map : hint_albedo;
uniform float gerstner_value : hint_range(0.0, 1.0) = 0.0f;
uniform float TextureRot : hint_range(-180, 180.0) = 0.0f;
uniform float TextureRot2 : hint_range(-180, 180.0) = 0.0f;
uniform float Roughness = 0.5f;
uniform float Spec = 0.5f;

uniform float gerstner_normal = 0.25;
//uniform float gerstner_stretch = 1.5;
uniform float gerstner_tiling = 0.1;
uniform float gerstner_2_normal = 0.2;
//uniform float gerstner_2_stretch = 2.0;
uniform float gerstner_2_tiling = 0.31;
uniform float gerstner_distance_fadeout = 0.04;
const vec2 gerstner_speed = vec2(0.0, -0.020);
const vec2 gerstner_2_speed = vec2(0.0, -0.016);
uniform float RainInt : hint_range(0.0, 1,0) = 0.0f;

//uniform float normal_base_intensity = 0.7;
//uniform float normal_peak_intensity = 1.5;
uniform float normal_dist_fadeout = 0.015;
//uniform float detail_normal_intensity = 0.05;
//uniform float detail_normal_tiling = 10.0;
//uniform float detail_normal_speed = 12.0;

//uniform float foam_ramp = 0.2;
uniform float foam_amount = 7.0;
uniform int foam_tiling = 8;
uniform float foam_gerstner = 5.0;

//uniform float wave_height = 0.3;
//uniform float wave_z_offset = -0.15;

uniform float beach_alpha_fadeout = 0.05;
uniform float beach_normal_fadeout = 0.3;

uniform float flow_blend_timing = 1.0;
uniform float flow_blend_stretch = 0.35;
uniform float water_color_depth = 1.0;

uniform float specam : hint_range(0.0, 1.0, 0.1);

uniform float sss_strength = 1.0;
uniform float MAX_RADIUS = 2.0;

// Hash functions shamefully stolen from:
// https://www.shadertoy.com/view/4djSRW
uniform float HASHSCALE1 = 0.1031;
uniform vec3 HASHSCALE3 = vec3(0.1031, 0.1030, 0.0973);

void vertex() {

	//float height = texture(gerstner_height_map, WORLD_MATRIX[3].xz * TIME).r;
	//VERTEX.y += height;
	float camera_distance = length(CAMERA_MATRIX[3].xyz - (WORLD_MATRIX[3].xyz - VERTEX)) / 1000.0;

	COLOR[0] = camera_distance;
}
vec2 rotateUV(vec2 uv, vec2 pivot, float rotation) {
	float cosa = cos(rotation);
	float sina = sin(rotation);
	uv -= pivot;
	return vec2(
		cosa * uv.x - sina * uv.y,
		cosa * uv.y + sina * uv.x 
	) + pivot;
}
//uniform float FADE_START;     // Distance at which fading starts
//uniform float FADE_END;       // Distance at which details are fully masked
void fragment() {
	//vec3 fragmentWorldPosition = (WORLD_MATRIX * vec4(UV.xy, 0.0, 1.0)).xyz;
	//float distanceFromCamera = length(vec3(0.5,0.0,0.5) - fragmentWorldPosition);

	// Calculate the fade factor based on the distance
	//float fadeFactor = smoothstep(FADE_START, FADE_END, distanceFromCamera);
	
	vec4 uv_base = vec4(UV.x, UV.y, UV.y, 1.0) * 6.0;
	vec2 world_offset = WORLD_MATRIX[3].xz * 0.025;
	vec2 uv_gerstner = (uv_base.xz + world_offset) * gerstner_tiling + TIME * rotateUV(gerstner_speed, vec2(0.0, 0.0), radians(-TextureRot));
	vec2 uv_gerstner_2 = (uv_base.xz + world_offset) * gerstner_2_tiling + TIME * rotateUV(gerstner_2_speed, vec2(0.0, 0.0), radians(-TextureRot2));
	
	vec2 uv = fract(uv_base.xz + world_offset);
	uv_gerstner = rotateUV(uv_gerstner, vec2(60.0, -59.5), radians(TextureRot));
	uv_gerstner_2 = rotateUV(uv_gerstner_2, vec2(60.0, -59.5), radians(TextureRot2));
	uv = rotateUV(uv, vec2(60.0, -60.0), radians(-TextureRot));


	vec3 normal_output = vec3(0.5, 0.5, 1.0);

	
	// GERSTNER WAVES
	vec3 normal_gerstner = texture(gerstner_normal_map, uv_gerstner).xyz - normal_output;
	vec3 normal_gerstner_2 = texture(gerstner_normal_map, uv_gerstner_2).xyz - normal_output;
	float height_gerstner = texture(gerstner_height_map, uv_gerstner).y;
	float height_gerstner_2 = texture(gerstner_height_map, uv_gerstner_2).y;

	//normal_output = vec3(0.5, 0.5, 1.0);

	normal_output += (normal_gerstner * gerstner_normal  * gerstner_value) + (normal_gerstner_2 * gerstner_2_normal  * (1.0 - gerstner_value) );
	normal_output = mix(normal_output, vec3(0.5, 0.5, 1.0), smoothstep(COLOR[0], 0.0, gerstner_distance_fadeout) );
	
	// FLOW TIMING FOR FLOW MAPS (USED IN FOAM AND BUBBLES) 2 UVs BLENDED TOGETHER
	float flow_timing = TIME * flow_blend_timing;
	float flow_timing_a = fract(flow_timing);

	
	vec2 uv_detail_a = fract( uv  * -flow_timing_a * flow_blend_stretch );
	

	vec4 tex = texture(DEPTH_TEXTURE, SCREEN_UV);
	float depths = tex.r;

	depths += VERTEX.z;
	
	
	depths = texture(DEPTH_TEXTURE, SCREEN_UV + (normal_output.xy * clamp(depths * 0.2, 0.0, 0.1) )).r;
	
	depths = depths * 2.0 - 1.0;
	
	depths = PROJECTION_MATRIX[3][2] / (depths + PROJECTION_MATRIX[2][2]); // Camera Z Depth to World Space Z
	depths += VERTEX.z;

	vec3 albedo_output = texture(water_color, vec2(depths * water_color_depth, 0.5)).xyz;

	vec3 albedo_foam_a = texture(foam_albedo_map, uv_detail_a * vec2(float(foam_tiling), float(foam_tiling)) ).xyz;
	
	height_gerstner = smoothstep(0.05, 1.0, height_gerstner);
	height_gerstner_2 = smoothstep(0.05, 1.0, height_gerstner_2);
	
	albedo_output = mix(albedo_output, albedo_foam_a, (1.0 - smoothstep(COLOR[0], 0.0, normal_dist_fadeout) ) * (foam_amount) + ((height_gerstner * foam_gerstner * gerstner_value) + (height_gerstner_2 * foam_gerstner *(1.0 - gerstner_value)) ) );

	float alpha_output = smoothstep(depths, -5.0, beach_alpha_fadeout);
	
	ALBEDO = clamp(albedo_output, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));
	//normal_output = mix(normal_output, vec3(0.5,0.5,1.0), fadeFactor);
	//ALBEDO = vec3(depths, 0.0, 0.0);
	NORMALMAP = clamp(normal_output, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));
	SPECULAR = Spec;
	ROUGHNESS = Roughness;
	METALLIC = 0.0;
	ALPHA = alpha_output;
	
	/*if (IsRaining)
	{
	    // Calculate resolution based on the ring width
	    float resolution = 10.0 * exp2(-3.0 / (1.0 / vec2(2.0, 2.0)).x);

	    // Scale down world coordinates to avoid precision issues
	    vec2 scaledWorldPos = mod(WORLD_MATRIX[3].xz, 10000.0);
	    vec2 uv2 = UV.xy / (1.0 / ring_width) * resolution + (scaledWorldPos * 0.294);
	    vec2 p0 = floor(uv2);

	    vec2 circles = vec2(0.0);

	    // Use fixed integer bounds for MAX_RADIUS to ensure proper loop iteration
	    int maxRadiusInt = int(MAX_RADIUS);

	    // Loop through surrounding points to calculate the rain effect
	    for (int j = -maxRadiusInt; j <= maxRadiusInt; ++j)
	    {
	        for (int i = -maxRadiusInt; i <= maxRadiusInt; ++i)
	        {
	            vec2 pi = p0 + vec2(float(i), float(j));

	            vec2 hsh = hash22(pi);
	            vec2 p = pi + hash22(hsh);

	            float t = fract(0.3 * TIME + hash12(hsh));
	            vec2 v = p - uv2;
	            float d = length(v) - (float(maxRadiusInt) + 1.0) * t;

	            // Smooth out the transition for the rain circles
	            float h = 1e-3;
	            float d1 = d - h;
	            float d2 = d + h;
	            float p1 = sin(31.0 * d1) * smoothstep(-0.6, -0.3, d1) * smoothstep(0.0, -0.3, d1);
	            float p2 = sin(31.0 * d2) * smoothstep(-0.6, -0.3, d2) * smoothstep(0.0, -0.3, d2);

	            circles += 0.5 * normalize(v) * ((p2 - p1) / (2.0 * h) * (1.0 - t) * (1.0 - t));
	        }
	    }

	    // Normalize the circles effect based on the number of iterations
	    circles /= float((maxRadiusInt * 2 + 1) * (maxRadiusInt * 2 + 1));

	    // Calculate rain intensity and normal map perturbation
	    float intensity = mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05 * TIME + 0.5) * 2.0 - 1.0)));
	    vec3 n = vec3(circles, sqrt(1.0 - dot(circles, circles)));
	    vec3 color = texture(water_color, uv2 / resolution - n.xy).rgb + 5.0 * pow(clamp(dot(n, normalize(vec3(1.0, 0.7, 0.5))), 0.0, 1.0), 6.0);
	    //n.z += 2.0;

	    // Mix the calculated normal and albedo with the rain effect
	    //NORMALMAP = mix(normal_output, n, RainInt * fadeFactor);
	    ALBEDO = mix(albedo_output, color, RainInt);
	}*/

}

void light() {
	// LAMBER DIFFUSE LIGHTING
	float pi = 3.14159265358979323846;
	float water_highlight_mask_1 = texture(water_highlight_map, fract( UV + (WORLD_MATRIX[3].xz * 0.00415) + TIME * 0.051031 ) ).x;
	float water_highlight_mask_2 = texture(water_highlight_map, fract( UV + (WORLD_MATRIX[3].xz * 0.00415) + TIME * -0.047854) * 2.0 ).x;
	
	// SUBSURFACE SCATTERING
	float sss = clamp( smoothstep(0.65, 0.7, dot(NORMAL , VIEW) * 0.5 + 0.5 ) * smoothstep(0.5, 1.0, (dot(-LIGHT, VIEW) * 0.5 + 0.5) ) * ( dot (-CAMERA_MATRIX[2].xyz, vec3(0.0, 1.0, 0.0)) * 0.5 + 0.5), 0.0, 1.0) * sss_strength;
		
	float lambert = clamp(dot(NORMAL, LIGHT), 0.0, 1.0);
	//float spec = clamp( pow( dot( reflect(LIGHT, NORMAL), -VIEW), 1000.0), 0.0, 1.0) * 2.0;
	float spec_glare = clamp( pow( dot( reflect(LIGHT, NORMAL), -VIEW), 100.0), 0.0, 1.0) * smoothstep(0.0, 0.1, water_highlight_mask_1 * water_highlight_mask_2) * 30.0;
	//spec *= specam;
	spec_glare *= specam;
	DIFFUSE_LIGHT += (LIGHT_COLOR * ALBEDO * ATTENUATION / pi) * lambert;
	DIFFUSE_LIGHT += (LIGHT_COLOR * ALBEDO * ATTENUATION / pi) * sss;
	DIFFUSE_LIGHT += LIGHT_COLOR * ATTENUATION * (spec_glare);
}"

[sub_resource type="OpenSimplexNoise" id=11]

[sub_resource type="NoiseTexture" id=12]
width = 1024
height = 1024
seamless = true
noise = SubResource( 11 )

[sub_resource type="GradientTexture" id=2]
gradient = ExtResource( 12 )

[resource]
shader = SubResource( 10 )
shader_param/IsRaining = true
shader_param/ring_width = 450.0
shader_param/gerstner_value = 1.0
shader_param/TextureRot = 0.0
shader_param/TextureRot2 = 0.0
shader_param/Roughness = 0.88
shader_param/Spec = 0.5
shader_param/gerstner_normal = 1.0
shader_param/gerstner_tiling = 0.3
shader_param/gerstner_2_normal = 2.0
shader_param/gerstner_2_tiling = 0.3
shader_param/gerstner_distance_fadeout = 9.561
shader_param/RainInt = 0.487889
shader_param/normal_dist_fadeout = 0.015
shader_param/foam_amount = 0.0
shader_param/foam_tiling = 1
shader_param/foam_gerstner = 47.877
shader_param/beach_alpha_fadeout = 0.183
shader_param/beach_normal_fadeout = 2.649
shader_param/flow_blend_timing = -0.15
shader_param/flow_blend_stretch = 0.35
shader_param/water_color_depth = 0.011
shader_param/specam = 1.0
shader_param/sss_strength = 1.0
shader_param/MAX_RADIUS = 2.5
shader_param/HASHSCALE1 = 1.0
shader_param/HASHSCALE3 = Vector3( 0.01, 0.01, 0.01 )
shader_param/water_color = SubResource( 2 )
shader_param/foam_normal_map = ExtResource( 10 )
shader_param/foam_albedo_map = SubResource( 12 )
shader_param/gerstner_height_map = ExtResource( 5 )
shader_param/gerstner_normal_map = ExtResource( 2 )
shader_param/water_highlight_map = ExtResource( 3 )
