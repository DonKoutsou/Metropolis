[gd_resource type="ShaderMaterial" load_steps=10 format=2]

[ext_resource path="res://Assets/Water/textures/water/gerstner_normal.png" type="Texture" id=2]
[ext_resource path="res://Assets/Water/textures/post/lense_glare_a.png" type="Texture" id=3]
[ext_resource path="res://Assets/Water/textures/water/gerstner_height.png" type="Texture" id=5]
[ext_resource path="res://Assets/Water/textures/water/foam_normal.png" type="Texture" id=10]
[ext_resource path="res://Assets/Water/textures/water/gradients/water_gradient_b.tres" type="Gradient" id=12]

[sub_resource type="Shader" id=10]
code = "shader_type spatial;

render_mode cull_disabled;

uniform bool IsRaining = false;

uniform float ring_width : hint_range(0.0, 500.0) = 50.0f;
//uniform float fadeout : hint_range(0.0, 1.0) = 0.2;
//uniform sampler2D pattern;
//uniform vec4 ring_color : hint_color;

uniform sampler2D water_color : hint_albedo;

uniform sampler2D foam_normal_map : hint_normal;
uniform sampler2D foam_albedo_map : hint_albedo;

uniform sampler2D gerstner_height_map : hint_albedo;
uniform sampler2D gerstner_normal_map : hint_normal;
//uniform sampler2D detail_normal_map : hint_normal;
uniform sampler2D water_highlight_map : hint_albedo;
uniform float gerstner_value : hint_range(0.0, 1.0) = 0.0f;
uniform float TextureRot : hint_range(-180, 180.0) = 0.0f;
uniform float TextureRot2 : hint_range(-180, 180.0) = 0.0f;
uniform float Roughness = 0.5f;
uniform float Spec = 0.5f;

uniform float gerstner_normal = 0.25;
//uniform float gerstner_stretch = 1.5;
uniform float gerstner_tiling = 0.1;
uniform float gerstner_2_normal = 0.2;
//uniform float gerstner_2_stretch = 2.0;
uniform float gerstner_2_tiling = 0.31;
uniform float gerstner_distance_fadeout = 0.04;
const vec2 gerstner_speed = vec2(0.0, -0.020);
const vec2 gerstner_2_speed = vec2(0.0, -0.016);
uniform float RainInt : hint_range(0.0, 1,0) = 0.0f;

//uniform float normal_base_intensity = 0.7;
//uniform float normal_peak_intensity = 1.5;
uniform float normal_dist_fadeout = 0.015;
//uniform float detail_normal_intensity = 0.05;
//uniform float detail_normal_tiling = 10.0;
//uniform float detail_normal_speed = 12.0;

//uniform float foam_ramp = 0.2;
uniform float foam_amount = 7.0;
uniform int foam_tiling = 8;
uniform float foam_gerstner = 5.0;

//uniform float wave_height = 0.3;
//uniform float wave_z_offset = -0.15;

uniform float beach_alpha_fadeout = 0.05;
uniform float beach_normal_fadeout = 0.3;

uniform float flow_blend_timing = 1.0;
uniform float flow_blend_stretch = 0.35;
uniform float water_color_depth = 1.0;

uniform float specam : hint_range(0.0, 1.0, 0.1);

uniform float sss_strength = 1.0;
uniform float MAX_RADIUS = 2.0;

// Hash functions shamefully stolen from:
// https://www.shadertoy.com/view/4djSRW
uniform float HASHSCALE1 = 0.1031;
uniform vec3 HASHSCALE3 = vec3(0.1031, 0.1030, 0.0973);

float hash12(vec2 p)
{
	vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
	p3 += dot(p3, p3.yzx + 19.19);
	return fract((p3.x + p3.y) * p3.z);
}

vec2 hash22(vec2 p)
{
	vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);
	p3 += dot(p3, p3.yzx+19.19);
	return fract((p3.xx+p3.yz)*p3.zy);
}
void vertex() {

	//float height = texture(gerstner_height_map, WORLD_MATRIX[3].xz * TIME).r;
	//VERTEX.y += height;
	float camera_distance = length(CAMERA_MATRIX[3].xyz - (WORLD_MATRIX[3].xyz - VERTEX)) / 1000.0;

	COLOR[0] = camera_distance;
}
vec2 rotateUV(vec2 uv, vec2 pivot, float rotation) {
	float cosa = cos(rotation);
	float sina = sin(rotation);
	uv -= pivot;
	return vec2(
		cosa * uv.x - sina * uv.y,
		cosa * uv.y + sina * uv.x 
	) + pivot;
}
void fragment() {
	vec2 gestnerspdrot = rotateUV(gerstner_speed,  vec2(0.0, 0.0), radians(-TextureRot));
	vec2 uv_gerstner = ( (vec4(UV.x, UV.y, UV.y, 1.0) * 6.0) + WORLD_MATRIX[3] * 0.025).xz * gerstner_tiling + vec2(TIME * gestnerspdrot.x, TIME * gestnerspdrot.y);
	vec2 gestnerspdrot2 = rotateUV(gerstner_2_speed,  vec2(0.0, 0.0), radians(-TextureRot2));
	vec2 uv_gerstner_2 = ( (vec4(UV.x, UV.y, UV.y, 1.0) * 6.0) + WORLD_MATRIX[3] * 0.025).xz * gerstner_2_tiling + vec2(TIME * gestnerspdrot2.x, TIME * gestnerspdrot2.y);
	
	vec2 uv = fract( (vec4(UV.x, UV.y, UV.y, 1.0) * 6.0) + WORLD_MATRIX[3] * 0.025 ).xz;

	uv_gerstner = rotateUV(uv_gerstner,  vec2(60.0, -59.5), radians(TextureRot));
	uv_gerstner_2 = rotateUV(uv_gerstner_2,  vec2(60.0, -59.5), radians(TextureRot2));
	uv = rotateUV(uv,  vec2(60.0, -60.0), radians(-TextureRot));

	vec3 normal_output = vec3(0,0,0);

	
	// GERSTNER WAVES
	vec3 normal_gerstner = texture(gerstner_normal_map, uv_gerstner).xyz - vec3(0.5, 0.5, 1.0);
	vec3 normal_gerstner_2 = texture(gerstner_normal_map, uv_gerstner_2).xyz - vec3(0.5, 0.5, 1.0);
	vec3 height_gerstner = texture(gerstner_height_map, uv_gerstner).xyz;
	vec3 height_gerstner_2 = texture(gerstner_height_map, uv_gerstner_2).xyz;

	
	//normal_output /= 6.0;
	
	// DETAIL NORMAL
	normal_output = vec3(0.5, 0.5, 1.0);
	//normal_output += ( texture(detail_normal_map, uv_gerstner * detail_normal_tiling - vec2(gerstner_speed.x * TIME, gerstner_speed.y * TIME) * detail_normal_speed ).xyz - vec3(0.5, 0.5, 1.0) ) * detail_normal_intensity;
	
	// ADDING SECOND GERSTNER WAVE
	normal_output += (normal_gerstner * gerstner_normal  * gerstner_value) + (normal_gerstner_2 * gerstner_2_normal  * (1.0 - gerstner_value) );
	normal_output = mix(normal_output, vec3(0.5, 0.5, 1.0), smoothstep(COLOR[0], 0.0, gerstner_distance_fadeout) );
	
	// FLOW TIMING FOR FLOW MAPS (USED IN FOAM AND BUBBLES) 2 UVs BLENDED TOGETHER
	float flow_timing = TIME * flow_blend_timing;
	float flow_timing_a = fract(flow_timing);

	
	vec2 uv_detail_a = fract( uv  * -flow_timing_a * flow_blend_stretch );
	
	// UNDERWATER
	vec2 scr = SCREEN_UV;

	vec4 tex = texture(DEPTH_TEXTURE, scr);
	float depths = tex.r; // LOOSING SS-REFLECTIONS
	
	// DEPTH REPROJECTION FROM CAMERA Z to Z Axis
	depths = depths * 2.0 - 1.0;

	depths = depths + VERTEX.z;
	
	
	depths = texture(DEPTH_TEXTURE, SCREEN_UV + (normal_output.xy * clamp(depths * 0.2, 0.0, 0.1) )).r;
	
	depths = depths * 2.0 - 1.0;
	
	depths = PROJECTION_MATRIX[3][2] / (depths + PROJECTION_MATRIX[2][2]); // Camera Z Depth to World Space Z
	depths = depths + VERTEX.z;
	
	//float depth_mask = clamp(depths , 0.0, 1.0);
	
	// WATER COLOR GRADIENT
	vec3 water_gradient = texture(water_color, vec2(depths * water_color_depth, 0.5)).xyz;
	vec3 albedo_output = water_gradient;

	//vec3 screen = textureLod(SCREEN_TEXTURE, SCREEN_UV + ((normal_output.xy - vec2(0.5, 0.5)) * clamp(depths * 1.0, 0.0, 0.1) ), 0.0).xyz; // LOOSING SS-REFLECTIONS

	// FOAM
	vec3 albedo_foam_a = texture(foam_albedo_map, uv_detail_a * vec2(float(foam_tiling), float(foam_tiling)) ).xyz;
	
	//albedo_output = mix(screen, albedo_output, depth_mask);

	
	//vec3 normal_foam_a = texture(foam_normal_map, uv_detail_a * vec2(float(foam_tiling), float(foam_tiling)) ).xyz - vec3(0.5, 0.5, 1.0);

	
	//float mask_foam = smoothstep(0, -0.4, foam_ramp);
	height_gerstner.y = smoothstep(0.05, 1.0, height_gerstner.y);
	height_gerstner_2.y = smoothstep(0.05, 1.0, height_gerstner_2.y);
	
	albedo_output = mix(albedo_output, albedo_output + albedo_foam_a, (1.0 - smoothstep(COLOR[0], 0.0, normal_dist_fadeout) ) * (foam_amount) + ((height_gerstner.y * foam_gerstner * gerstner_value) + (height_gerstner_2.y * foam_gerstner *(1.0 - gerstner_value)) ) );
	normal_output = mix(normal_output, normal_output , (1.0 - smoothstep(COLOR[3], 0.0, normal_dist_fadeout) ) * (foam_amount) + ((height_gerstner.y * foam_gerstner * gerstner_value) + (height_gerstner_2.y * foam_gerstner *(1.0 - gerstner_value)) ) );
	
	// BEACH
	normal_output = mix(vec3(0.5, 0.5, 1.0), normal_output, clamp( smoothstep(depths, 0.0, beach_normal_fadeout), 0.5, 1.0)); // smooth out
	float alpha_output = smoothstep(depths, -5.0, beach_alpha_fadeout);
	
	ALBEDO = clamp(albedo_output, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));
	//ALBEDO = vec3(depths, 0.0, 0.0);
	NORMALMAP = clamp(normal_output, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));
	SPECULAR = Spec;
	ROUGHNESS = Roughness;
	METALLIC = 0.0;
	ALPHA = alpha_output;
	/*if (IsRaining)
	{
		float resolution = 10.0 * exp2(-3.0 / (1.0 / vec2(2.0, 2.0)).x);
		vec2 uv2 = UV.xy / (1.0 /  ring_width ) * resolution + (WORLD_MATRIX[3].xz * 0.294);
		vec2 p0 = floor(uv2);

		vec2 circles = vec2(0.0);
		for (float j = -MAX_RADIUS; j <= MAX_RADIUS; ++j)
		{
			for (float i = -MAX_RADIUS; i <= MAX_RADIUS; ++i)
			{
				vec2 pi = p0 + vec2(i, j);
				
				vec2 hsh = hash22(pi);
				
				vec2 p = pi + hash22(hsh);
				
				float t = fract(0.3 * TIME + hash12(hsh));
				vec2 v = p - uv2;
				float d = length(v) - (float(MAX_RADIUS) + 1.)*t;
				
				float h = 1e-3;
				float d1 = d - h;
				float d2 = d + h;
				float p1 = sin(31.*d1) * smoothstep(-0.6, -0.3, d1) * smoothstep(0., -0.3, d1);
				float p2 = sin(31.*d2) * smoothstep(-0.6, -0.3, d2) * smoothstep(0., -0.3, d2);
				circles += 0.5 * normalize(v) * ((p2 - p1) / (2. * h) * (1. - t) * (1. - t));
			}
		}
		
		circles /= float((MAX_RADIUS * 2.0 + 1.0) * (MAX_RADIUS * 2.0 + 1.0));
		
		float intensity = mix(0.01, 0.15, smoothstep(0.1, 0.6, abs(fract(0.05 * TIME + 0.5) * 2.0 -1.0)));
		vec3 n = vec3(circles, sqrt(1.0 - dot(circles, circles)));
		vec3 color = texture(water_color, uv2/resolution - n.xy).rgb + 5.0 * pow(clamp(dot(n, normalize(vec3(1.0, 0.7, 0.5))), 0.0, 1.0), 6.0);
		n.z += 2.0;
		NORMALMAP = mix(normal_output, n, RainInt);
		ALBEDO = mix(albedo_output, color, RainInt);
	}*/
}

void light() {
	// LAMBER DIFFUSE LIGHTING
	float pi = 3.14159265358979323846;
	float water_highlight_mask_1 = texture(water_highlight_map, fract( UV + (WORLD_MATRIX[3].xz * 0.00415) + TIME * 0.051031 ) ).x;
	float water_highlight_mask_2 = texture(water_highlight_map, fract( UV + (WORLD_MATRIX[3].xz * 0.00415) + TIME * -0.047854) * 2.0 ).x;
	
	// SUBSURFACE SCATTERING
	float sss = clamp( smoothstep(0.65, 0.7, dot(NORMAL , VIEW) * 0.5 + 0.5 ) * smoothstep(0.5, 1.0, (dot(-LIGHT, VIEW) * 0.5 + 0.5) ) * ( dot (-CAMERA_MATRIX[2].xyz, vec3(0.0, 1.0, 0.0)) * 0.5 + 0.5), 0.0, 1.0) * sss_strength;
		
	float lambert = clamp(dot(NORMAL, LIGHT), 0.0, 1.0);
	float spec = clamp( pow( dot( reflect(LIGHT, NORMAL), -VIEW), 1000.0), 0.0, 1.0) * 2.0;
	float spec_glare = clamp( pow( dot( reflect(LIGHT, NORMAL), -VIEW), 100.0), 0.0, 1.0) * smoothstep(0.0, 0.1, water_highlight_mask_1 * water_highlight_mask_2) * 30.0;
	spec *= specam;
	spec_glare *= specam;
	DIFFUSE_LIGHT += (LIGHT_COLOR * ALBEDO * ATTENUATION / pi) * lambert;
	DIFFUSE_LIGHT += (LIGHT_COLOR * ALBEDO * ATTENUATION / pi) * sss;
	DIFFUSE_LIGHT += LIGHT_COLOR * ATTENUATION * (spec + spec_glare);
}"

[sub_resource type="OpenSimplexNoise" id=11]

[sub_resource type="NoiseTexture" id=12]
width = 1024
height = 1024
seamless = true
noise = SubResource( 11 )

[sub_resource type="GradientTexture" id=2]
gradient = ExtResource( 12 )

[resource]
shader = SubResource( 10 )
shader_param/IsRaining = false
shader_param/ring_width = 450.0
shader_param/gerstner_value = 1.0
shader_param/TextureRot = 0.0
shader_param/TextureRot2 = 0.0
shader_param/Roughness = 0.941
shader_param/Spec = 0.5
shader_param/gerstner_normal = 0.606
shader_param/gerstner_tiling = 0.3
shader_param/gerstner_2_normal = 0.267
shader_param/gerstner_2_tiling = 0.3
shader_param/gerstner_distance_fadeout = 9.561
shader_param/RainInt = 0.487889
shader_param/normal_dist_fadeout = 0.015
shader_param/foam_amount = 0.0
shader_param/foam_tiling = 1
shader_param/foam_gerstner = 47.877
shader_param/beach_alpha_fadeout = 0.183
shader_param/beach_normal_fadeout = 2.649
shader_param/flow_blend_timing = -0.15
shader_param/flow_blend_stretch = 0.35
shader_param/water_color_depth = 0.011
shader_param/specam = 1.0
shader_param/sss_strength = 1.0
shader_param/MAX_RADIUS = 2.5
shader_param/HASHSCALE1 = 1.0
shader_param/HASHSCALE3 = Vector3( 0.01, 0.01, 0.01 )
shader_param/water_color = SubResource( 2 )
shader_param/foam_normal_map = ExtResource( 10 )
shader_param/foam_albedo_map = SubResource( 12 )
shader_param/gerstner_height_map = ExtResource( 5 )
shader_param/gerstner_normal_map = ExtResource( 2 )
shader_param/water_highlight_map = ExtResource( 3 )
