[gd_resource type="ShaderMaterial" load_steps=10 format=2]

[ext_resource path="res://Assets/TerainTex/Rock030_1K-JPG/Rock030_1K-JPG_Color.jpg" type="Texture" id=1]
[ext_resource path="res://Assets/TerainTex/Sand/Stylized_Sand_001_basecolor.jpg" type="Texture" id=2]
[ext_resource path="res://Assets/TerainTex/Rock030_1K-JPG/Rock030_1K-JPG_NormalGL.jpg" type="Texture" id=3]
[ext_resource path="res://Assets/TerainTex/Rock030_1K-JPG/Rock030_1K-JPG_Roughness.jpg" type="Texture" id=4]
[ext_resource path="res://Assets/TerainTex/Sand/Stylized_Sand_001_normal.jpg" type="Texture" id=5]
[ext_resource path="res://Assets/TerainTex/Sand/Stylized_Sand_001_roughness.jpg" type="Texture" id=6]
[ext_resource path="res://Assets/TerainTex/Sand/Stylized_Sand_001_ambientOcclusion.jpg" type="Texture" id=7]
[ext_resource path="res://Assets/TerainTex/Rock030_1K-JPG/Rock030_1K-JPG_AmbientOcclusion.jpg" type="Texture" id=8]

[sub_resource type="Shader" id=1]
code = "shader_type spatial;
render_mode diffuse_lambert;
// Varyings
varying float flatness;
varying vec3 power_normal;
varying vec3 object_normal;
varying vec3 world_normal;
varying vec3 triplanar_pos;

uniform float WallTexScale;
uniform sampler2D WallTex;
uniform sampler2D WallTexR;
uniform sampler2D WallTexN;
uniform sampler2D WallTexAO;
uniform vec4 WallColor;
uniform float TopTexScale;
uniform float ao_light_affect;
uniform sampler2D TopTex;
uniform sampler2D TopTexR;
uniform sampler2D TopTexN;
uniform sampler2D TopTexAO;
uniform vec4 TopColor;
uniform vec4 BlendValues = vec4(3,-2,0,1);
uniform vec4 roughness_texture_channel;
uniform vec4 ao_texture_channel;
vec2 hash( vec2 p )
{
	return fract( sin( p * mat2( vec2( 127.1, 311.7 ), vec2( 269.5, 183.3 ) ) ) * 43758.5453 );
}
vec3 unpack_normal(vec4 rgba) {
	// If we consider texture space starts from top-left corner and Y goes down,
	// then Y+ in pixel space corresponds to Z+ in terrain space,
	// while X+ also corresponds to X+ in terrain space.
	vec3 n = rgba.xzy * 2.0 - vec3(1.0);
	// Had to negate Z because it comes from Y in the normal map,
	// and OpenGL-style normal maps are Y-up.
	n.z *= -1.0;
	return n;
}
void vertex(){
	object_normal = NORMAL;
	world_normal = vec3(0.0,1.0,0.0);
	flatness = dot(object_normal,world_normal);
	power_normal = normalize(pow(abs(object_normal),vec3(10.0,10.0,10.0)));
	triplanar_pos = VERTEX*vec3(1.0,-1.0,1.0);
}

vec4 stochastic_sample(sampler2D tex, vec2 uv){
	vec2 skewV = mat2(vec2(1.0,1.0),vec2(-0.57735027 , 1.15470054))*uv * 3.464;
	
	vec2 vxID = floor(skewV);
	vec2 fracV = fract(skewV);
	vec3 barry = vec3(fracV.x,fracV.y,1.0-fracV.x-fracV.y);
	
	mat4 bw_vx = barry.z>0.0?
		mat4(vec4(vxID,0.0,0.0),vec4((vxID+vec2(0.0,1.0)),0.0,0.0),vec4(vxID+vec2(1.0,0.0),0,0),vec4(barry.zyx,0)):
		mat4(vec4(vxID+vec2(1.0,1.0),0.0,0.0),vec4((vxID+vec2(1.0,0.0)),0.0,0.0),vec4(vxID+vec2(0.0,1.0),0,0),vec4(-barry.z,1.0-barry.y,1.0-barry.x,0));
		
	vec2 ddx = dFdx(uv);
	vec2 ddy = dFdy(uv);
	
	return (textureGrad(tex,uv+hash(bw_vx[0].xy),ddx,ddy)*bw_vx[3].x) +
	(textureGrad(tex,uv+hash(bw_vx[1].xy),ddx,ddy)*bw_vx[3].y) +
	(textureGrad(tex,uv+hash(bw_vx[2].xy),ddx,ddy)*bw_vx[3].z)
	;
	
}

vec4 triplanar_texture(sampler2D p_sampler, vec3 p_weights, vec3 p_triplanar_pos, float uv_scale) {
	vec4 samp = vec4(0.0);
	samp += stochastic_sample(p_sampler, p_triplanar_pos.xy*vec2(uv_scale,uv_scale)) * p_weights.z;
	samp += stochastic_sample(p_sampler, p_triplanar_pos.xz*vec2(uv_scale,uv_scale)) * p_weights.y;
	samp += stochastic_sample(p_sampler, p_triplanar_pos.zy * vec2(-1.0,1.0)*vec2(uv_scale,uv_scale)) * p_weights.x;
	return samp;
}


void fragment() {
	vec4 wall_tex = triplanar_texture(WallTex, power_normal, triplanar_pos,WallTexScale);
	vec4 wall_texr= triplanar_texture(WallTexR,power_normal, triplanar_pos,WallTexScale);
	float wallroughness_tex = dot(wall_texr,roughness_texture_channel);
	vec4 wall_texN = triplanar_texture(WallTexN, power_normal, triplanar_pos,WallTexScale);
	vec3 wall = wall_tex.rgb * WallColor.rgb;
	vec4 wall_texAO = triplanar_texture(WallTexAO, power_normal, triplanar_pos,WallTexScale);
	float wallao_tex = dot(wall_texAO,ao_texture_channel);
	vec4 top_tex = triplanar_texture(TopTex, power_normal, triplanar_pos,TopTexScale);
	vec4 top_texr= triplanar_texture(TopTexR,power_normal, triplanar_pos,TopTexScale);
	float toproughness_tex = dot(top_texr,roughness_texture_channel);
	vec4 top_texn= triplanar_texture(TopTexN,power_normal, triplanar_pos,TopTexScale);
	vec3 top = top_tex.rgb * TopColor.rgb;
	vec4 top_texao= triplanar_texture(TopTexAO,power_normal, triplanar_pos,TopTexScale); 
	float topao_tex = dot(top_texao,ao_texture_channel); 
	float blend = clamp((flatness*BlendValues.x)+BlendValues.y,BlendValues.y,BlendValues.w);
	ALBEDO = mix(wall,top,blend);
	ROUGHNESS = mix (wallroughness_tex, toproughness_tex, blend);
	
	NORMALMAP = mix(wall_texN.rgb, top_texn.rgb, blend);
	AO = mix (wallao_tex, topao_tex, blend);
	AO_LIGHT_AFFECT = ao_light_affect;
}"

[resource]
shader = SubResource( 1 )
shader_param/WallTexScale = 6.653
shader_param/WallColor = Plane( 1, 1, 1, 0 )
shader_param/TopTexScale = 9.414
shader_param/ao_light_affect = 2.0
shader_param/TopColor = Plane( 1, 1, 1, 0 )
shader_param/BlendValues = Plane( 3, -2, 0, 1 )
shader_param/roughness_texture_channel = Plane( 0, 0, 0, 1 )
shader_param/ao_texture_channel = Plane( 1, 0, 0, 0 )
shader_param/WallTex = ExtResource( 1 )
shader_param/WallTexR = ExtResource( 4 )
shader_param/WallTexN = ExtResource( 3 )
shader_param/WallTexAO = ExtResource( 8 )
shader_param/TopTex = ExtResource( 2 )
shader_param/TopTexR = ExtResource( 6 )
shader_param/TopTexN = ExtResource( 5 )
shader_param/TopTexAO = ExtResource( 7 )
